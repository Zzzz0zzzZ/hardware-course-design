ori $16, $0, 1	# 把1与0号寄存器进行或运算，结果存16号寄存器
ori $17, $0, 3	# 把3与0号寄存器进行或运算，结果存17号寄存器
ori $8, $0, 1	# 把1与0号寄存器进行或运算，结果存8号寄存器
ori $12, $0,0xabab	# 十六进制数abab与0号寄存器相或，结果存12号寄存器
lui $13, 10	# 把10加载到32位数的高位，低位补0，存13号寄存器
start:addu $4, $0,$16	# 0号寄存器内容 和 16号寄存器内容 进行无符号加法，结果存4号寄存器
addu $5, $0,$8	# 8号寄存器内容 和 0号寄存器内容 进行无符号加法，结果存5号寄存器
jal newadd	# 跳转到newadd处，同时保存下一条指令地址到31号寄存器
addu $16, $0, $2	# 2号寄存器内容 和 0号寄存器内容 进行无符号加法，结果存16号寄存器
subu $17,$17,$8		# 17号寄存器内容 和 8号寄存器内容 进行无符号减法，结果存17号寄存器
beq $16, $17, start	# 比较 16号寄存器内容 和 17号寄存器内容 ： 相等则跳转到start处
ori $8, $0,4		# 把4与0号寄存器相或，结果存8号寄存器
addiu $24,$0,0x7fffffff	# 0号寄存器内容加立即数7fffffff（十六进制）的结果，存入24号寄存器 （无符号加）
addiu $9,$24,3		# 24号寄存器内容与3相加的结果（无符号加法）存9号寄存器
addiu $10,$24,5		# 24号寄存器内容与5进行无符号加法的结果，存10号寄存器
addu $0,$0,$0		# 0号寄存器与0号寄存器进行无符号加法的结果存0号寄存器。（理论上0号寄存器不能被写入）
#addi $22,$24,6		# 6与24号寄存器内容进行有符号加法，结果存入22寄存器，若产生溢出，30号寄存器存1 （实验要求）
start2:sw $9, -4($8)	# 9号寄存器内容存入以8号寄存器内容为基地址，并向左偏移4的地址的存储空间中
sw $1, 0($8)		# 1号寄存器内容存入以8号寄存器内容为基地址，偏移0的地址的存储单元中
lb $14, 3($8)		# 以8号寄存器内容为基地址，加上偏移量3后的地址的存储单元内容的低8位，符号扩展后加载到14号寄存器
sb $12,7($8)		# 12号寄存器内容低8位存储到以8号寄存器内容为基地址，偏移7后的地址的存储单元中
lw $15,4($8)		# 以8号寄存器为基地址，偏移4后的地址的存储单元中的数据，加载到15号寄存器中
sb $4, -3($8)		# 4号寄存器内容低8位存入以8号寄存器为基地址，加上偏移量-3后的地址的存储单元中
lb $18, -1($8)		# 以8号寄存器为基地址，加上偏移量-1后的地址的存储单元内容的低8位，符号扩展后加载到18号寄存器
addu $4,$0,$8		# 8号寄存器内容 与 0号寄存器内容 进行无符号加法，结果存入4号寄存器
addu $5,$0,$9		# 9号寄存器内容 与 0号寄存器内容 进行无符号加法，结果存入5号寄存器
jal newadd		# 将当前指令地址加4的内容（下一条指令地址）存入31号寄存器，跳转到newadd
slt $25,$10,$8		# 如果10号寄存器内容 小于 8号寄存器内容， 25号寄存器内容置1， 否则置0
beq $25, $0,end2	# 比较25号寄存器 与 0号寄存器内容（0）， 相等则跳转end2处，否则顺序执行
slt $20,$12,$4		# 如果12号寄存器内容 小于 4号寄存器内容， 20号寄存器内容置1， 否则置0
beq $20, $0, end1	# 比较20号寄存器 与 0号寄存器内容（0）， 相等则跳转end1处，否则顺序执行
lui $12, 65535		# 将十进制65535加载到32位的高16位，低16位补0， 扩展结果存入12号寄存器
end1:ori $0, $0,1	# 0号寄存器内容 与 1 相或， 结果存0号寄存器（实际上0号寄存器不允许写入）
lui $19, 0xefef		# 十六进制数efef加载至32位中的高16位，低位补0， 结果存入19号寄存器
addiu $3,$0,0xababcdcd	# 0号寄存器内容 无符号加立即数 ababcdcd（十六进制）， 结果存入3号寄存器中
start3:addiu $4, $3, 2	# 3号寄存器内容 无符号加立即数2， 结果存入4号寄存器中
addi $23, $3, 5		# 3号寄存器内容 加 5， 有符号数的加法， 结果存23号寄存器。若结果溢出，30号寄存器存1，否则为0
jal newadd		# 将下一条指令地址存入31号寄存器后， 跳转到newadd处
addu $8, $0, $2		# 0号寄存器内容 与 2号寄存器内容 进行无符号加法， 结果存8号寄存器
addu $4, $0, $8		# 0号寄存器内容 与 8号寄存器内容 进行无符号加法， 结果存4号寄存器
addu $5, $0, $9		# 0号寄存器内容 与 9号寄存器内容 进行无符号加法， 结果存5号寄存器
jal newadd		# 将下一条指令地址存入31号寄存器后， 跳转到newadd处
addu $9, $0, $2		# 将2号寄存器内容与0号寄存器内容进行无符号加法，结果存入9号寄存器
addu $9, $8, $0		# 将0号寄存器内容与8号寄存器内容进行无符号加法，结果存入9号寄存器
lui $10, 0x69		# 将十六进制数69加载到32位数的高16位，低位补0，结果存入10号寄存器
beq $8, $9, start4	# 比较8号寄存器 和 9号寄存器的内容， 相等跳转start4处，否则顺序执行
beq $0, $0, start3	# 比较0号寄存器 和 0号寄存器的内容， 相等跳转start3处，否则顺序执行
start4:j end		# 无条件跳转end处
newadd:addu $2, $4, $5	# 4号寄存器内容 无符号加 5号寄存器内容， 结果存入2号寄存器中
addi $0,$12,0x1234	# 十六进制数1234 和12号寄存器的内容 有符号加法， 结果存0寄存器（0寄存器理论上无法被写入）
jr $31			# 跳转到 31号寄存器存储的内容 所指示的地址处
end2:addi $26,$0,0x5678	# 十六进制数5678 和 0号寄存器内容 有符号加法， 结果存26号寄存器
end:			# end标志处
